# User preference
# ───────────────

set-option global autoinfo command|onkey|normal
set-option global autoreload true
set-option global autowrap_column 80
set-option global grepcmd "rg --column --follow"
set-option global tabstop 4
set-option global ui_options ncurses_assistant=none

colorscheme gruvbox-hard-contrast

add-highlighter global/ show-matching
add-highlighter global/ show-whitespaces -spc " "
add-highlighter global/trailing-whitespace regex "\h+$" 0:default,red

# for everything except built-in read-only buffers
hook global WinCreate ^[^*]+$ %{
    add-highlighter window/ number-lines -hlcursor -relative
    lint-enable
}

# Enable editor config
# ────────────────────

hook global BufOpenFile .* %{ editorconfig-load }
hook global BufNewFile .* %{ editorconfig-load }

# Filetype specific hooks
# ───────────────────────

hook global WinSetOption filetype=git-(commit|rebase) %{
    set-option window autowrap_column 72
}

hook global WinSetOption filetype=go %{
    set-option window formatcmd "gofmt -s"
    set-option window lintcmd "golint"
    hook buffer BufWritePre .* %{
        go-format -use-goimports
        lint
    }
}

hook global WinSetOption filetype=markdown %{
    set-option window formatcmd "prettier --parser markdown"
}

hook global WinSetOption filetype=python %{
    set-option window formatcmd "black"
}

hook global WinSetOption filetype=rust %{
    set-option window formatcmd "rustfmt"
    hook buffer BufWritePre .* %{ format }
}

hook global WinSetOption filetype=sh %{
    set-option window formatcmd "shfmt"
    set-option window lintcmd "shellcheck --format=gcc"
    hook buffer BufWritePre .* %{ lint }
}

hook global WinSetOption filetype=yaml %{
    set-option window formatcmd "prettier --parser yaml"
    set-option window lintcmd "yamllint -f parsable"
    hook buffer BufWritePre .* %{ lint }
}

hook global -always BufOpenFifo "\*grep\*" %{ map global normal "'" ":grep-next-match<ret>" }
hook global -always BufOpenFifo "\*lint-output\*" %{ map global normal "'" ":lint-next-error<ret>" }
hook global -always BufOpenFifo "\*make\*" %{ map global normal "'" ":make-next-error<ret>" }

# Various mappings
# ────────────────

map -- global normal - ": lf<ret>"
map global normal "#" ": comment-line<ret>"
map global normal = ": format<ret>"
map global normal <c-g> ":grep "
map global normal <c-p> ": fzf-files<ret>"
map global normal + ": lint<ret>"

map global user -docstring "Run the make utility wrapper with no arguments" m ": make<ret>"
map global user -docstring "Format lines to a width of `autowrap_column` characters" q "|par -w $kak_opt_autowrap_column<ret>"

# Helper commands
# ───────────────

define-command fzf-files \
    -docstring "fzf: fuzzy find files to select buffers to open" \
    %{ evaluate-commands %{ fzf --multi }
}

define-command -hidden fzf -params .. \
    %{ evaluate-commands %{
        terminal sh -c "export PATH=%val(client_env_PATH) kak_session=%val(session) kak_client=%val(client); cd %val{client_env_PWD} && %val{config}/scripts/fzf.sh %arg(@)"
    }
}

define-command lf \
    -params ..1 -file-completion \
    -docstring "lf [<path>]: launch file system explorer to select buffers to open
    The optional path argument will set the initial location" \
    %{ evaluate-commands %sh{
        if [ $# -ge 1 ] && [ -e $1 ]; then
            path=$1
        elif [ -f $kak_buffile ]; then
            path=$kak_buffile
        else
            path=$PWD
        fi
        printf 'lf- "%s"\n' "$path"
    }
}

define-command -hidden lf- \
    -params ..1 -file-completion \
    %{ evaluate-commands %{
        terminal sh -c "export kak_session=%val(session) kak_client=%val(client); %val{config}/scripts/lf.sh %arg(1)"
    }
}

define-command new-docs %{
    rename-client main
    set-option global jumpclient main

    new rename-client docs
    set-option global docsclient docs
}

define-command new-tools %{
    rename-client main
    set-option global jumpclient main

    new rename-client tools
    set-option global toolsclient tools
}

# tig blame +%val{cursor_line} %val{buffile}

define-command trim-trailing-whitespace %{
  try %{ execute-keys -draft <a-x> s \h+$ <ret> d }
}

# Third-party plugins
# ───────────────────

# source "%val{config}/plugins/plug.kak/rc/plug.kak"
# plug "andreyorst/plug.kak" noload

# plug "andreyorst/fzf.kak" config %{
#     map -docstring "fzf mode" global normal "<c-p>" ": fzf-mode<ret>"
#     set-option global fzf_preview_width "65%"
#     set-option global fzf_highlighter "bat"
#     # evaluate-commands %sh{
#     #     if [ ! -z "$(command -v fd)" ]; then
#     #         echo "set-option global fzf_file_command 'fd . --no-ignore --type f --follow --hidden'"
#     #     fi
#     # }
# }

# System clipboard handling
# ─────────────────────────

evaluate-commands %sh{
    case $(uname) in
        Linux) copy="xclip -i"; paste="xclip -o" ;;
        Darwin) copy="pbcopy"; paste="pbpaste" ;;
    esac

    printf "map global user -docstring 'Paste (after) from system clipboard' p '!%s<ret>'\n" "$paste"
    printf "map global user -docstring 'Paste (before) from system clipboard' P '<a-!>%s<ret>'\n" "$paste"
    printf "map global user -docstring 'Yank to system clipboard' y '<a-|>%s<ret>: echo -markup %%{{Information}copied selection to system clipboard}<ret>'\n" "$copy"
    printf "map global user -docstring 'Replace from system clipboard' R '|%s<ret>'\n" "$paste"
}

# Load local Kakoune config file if it exists
# ───────────────────────────────────────────
evaluate-commands %sh{
    [ -f $kak_config/kakrc.local ] && echo "source $kak_config/kakrc.local"
}
