source "%val{config}/plugins/plug.kak/rc/plug.kak"
plug "andreyorst/plug.kak" noload

plug "andreyorst/fzf.kak" config %{
    map -docstring "fzf mode" global normal "<c-p>" ": fzf-mode<ret>"
    set-option global fzf_preview_width "65%"
    set-option global fzf_highlighter "bat"
    # evaluate-commands %sh{
    #     if [ ! -z "$(command -v fd)" ]; then
    #         echo "set-option global fzf_file_command 'fd . --no-ignore --type f --follow --hidden'"
    #     fi
    # }
}

# User preference
# ───────────────

set-option -add global autoinfo normal
set-option global autoreload true
set-option global tabstop 4
set-option global grepcmd "rg --column --follow"
set-option global ui_options ncurses_assistant=none

colorscheme gruvbox

add-highlighter global/ show-matching
add-highlighter global/ show-whitespaces -spc " "

hook global WinCreate ^[^*]+$ %{
    add-highlighter window/ number-lines -hlcursor -relative
    lint-enable
}

# Enable editor config
# ────────────────────

hook global BufOpenFile .* %{ editorconfig-load }
hook global BufNewFile .* %{ editorconfig-load }

# Filetype specific hooks
# ───────────────────────

hook global WinSetOption filetype=go %{
    set-option window formatcmd "gofmt"
    set-option window lintcmd "golint"
}

hook global WinSetOption filetype=markdown %{
    set-option window formatcmd "prettier --parser markdown"
}

hook global WinSetOption filetype=python %{
    set-option window formatcmd "black"
}

hook global WinSetOption filetype=rust %{
    set-option window formatcmd "rustfmt"
}

hook global WinSetOption filetype=sh %{
    set-option window formatcmd "shfmt"
    set-option window lintcmd "shellcheck --format=gcc"
}

hook global WinSetOption filetype=yaml %{
    set-option window formatcmd "prettier --parser yaml"
    set-option window lintcmd "yamllint -f parsable"
}

# System clipboard handling
# ─────────────────────────

evaluate-commands %sh{
    case $(uname) in
        Linux) copy="xclip -i"; paste="xclip -o" ;;
        Darwin) copy="pbcopy"; paste="pbpaste" ;;
    esac

    printf "map global user -docstring 'Paste (after) from system clipboard' p '!%s<ret>'\n" "$paste"
    printf "map global user -docstring 'Paste (before) from system clipboard' P '<a-!>%s<ret>'\n" "$paste"
    printf "map global user -docstring 'Yank to system clipboard' y '<a-|>%s<ret>: echo -markup %%{{Information}copied selection to system clipboard}<ret>'\n" "$copy"
    printf "map global user -docstring 'Replace from system clipboard' R '|%s<ret>'\n" "$paste"
}

# Various mappings
# ────────────────

map global normal "#" ": comment-line<ret>"
map global normal <c-g> ":grep "

hook global -always BufOpenFifo "\*grep\*" %{ map -- global normal - ":grep-next-match<ret>" }
hook global -always BufOpenFifo "\*lint-output\*" %{ map -- global normal - ":lint-next-error<ret>" }
hook global -always BufOpenFifo "\*make\*" %{ map -- global normal - ":make-next-error<ret>" }

map global user -docstring "Format the contents of the current buffer" f ": format<ret>"
map global user -docstring "Parse the current buffer with a linter" l ": lint<ret>"
map global user -docstring "Run the make utility wrapper with no arguments" m ": make<ret>"
map global user -docstring "Format lines to a width of 80 characters" q "|fmt -w 80<ret>"

# set-face global TrailingWhitespace yellow

# hook -group git-commit-highlight global WinSetOption filetype=git-(commit|rebase) %{
#     add-highlighter window/git-commit-highlight/ regex "\A[\s\n]*[^#\s][^\n]{49}([^\n]+)" 1:GitOverflowTitle
# }


# Helper commands
# ───────────────

define-command ide %{
    rename-client main
    set-option global jumpclient main

    new rename-client tools
    set-option global toolsclient tools

    new rename-client docs
    set-option global docsclient docs
}

define-command trim-trailing-whitespace %{
  try %{ execute-keys -draft <a-x> s \h+$ <ret> d }
}

# Load local Kakoune config file if it exists
# ───────────────────────────────────────────
evaluate-commands %sh{
    [ -f $kak_config/kakrc.local ] && echo "source $kak_config/kakrc.local"
}




# def suspend-and-resume \
#     -params 1..2 \
#     -docstring 'suspend-and-resume <cli command> [<kak command after resume>]: backgrounds current kakoune client and runs specified cli command.  Upon exit of command the optional kak command is executed.' \
#     %{ evaluate-commands %sh{

#     # Note we are adding '&& fg' which resumes the kakoune client process after the cli command exits
#     cli_cmd="$1 && fg"
#     post_resume_cmd="$2"

#     # automation is different platform to platform
#     platform=$(uname -s)
#     case $platform in
#         Darwin)
#             automate_cmd="sleep 0.01; osascript -e 'tell application \"System Events\" to keystroke \"$cli_cmd\\n\" '"
#             kill_cmd="/bin/kill"
#             break
#             ;;
#         Linux)
#             automate_cmd="sleep 0.2; xdotool type '$cli_cmd'; xdotool key Return"
#             kill_cmd="/usr/bin/kill"
#             break
#             ;;
#     esac

#     # Uses platforms automation to schedule the typing of our cli command
#     nohup sh -c "$automate_cmd"  > /dev/null 2>&1 &
#     # Send kakoune client to the background
#     $kill_cmd -SIGTSTP $kak_client_pid

#     # ...At this point the kakoune client is paused until the " && fg " gets run in the $automate_cmd

#     # Upon resume, run the kak command is specified
#     if [ ! -z "$post_resume_cmd" ]; then
#         echo "$post_resume_cmd"
#     fi
# }}

# def tig-blame -override -docstring 'Open blame in tig for current file and line' %{
#     # Note here we aren't passing any command on resume of kakoune
#     suspend-and-resume "tig blame +%val{cursor_line} %val{buffile}"
# }

# declare-user-mode tig
# map global tig b ': tig-blame<ret>' -docstring 'show blame (with tig)'
# map global tig s ': suspend-and-resume "tig status"<ret>' -docstring 'show git status (with tig)'
# map global tig m ': suspend-and-resume "tig"<ret>' -docstring 'show main view (with tig)'

# map global user t ': enter-user-mode tig<ret>' -docstring 'tig commands'

# def for-each-line \
#     -docstring "for-each-line <command> <path to file>: run command with the value of each line in the file" \
#     -params 2 \
#     %{ evaluate-commands %sh{

#     while read f; do
#         printf "$1 $f\n"
#     done < "$2"
# }}

# def toggle-ranger %{
#     suspend-and-resume \
#         "ranger --choosefiles=/tmp/ranger-files-%val{client_pid}" \
#         "for-each-line edit /tmp/ranger-files-%val{client_pid}"
# }

# map global user r ': toggle-ranger<ret>' -docstring 'select files in ranger'
